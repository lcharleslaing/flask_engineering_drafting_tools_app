{% extends "base.html" %}

{% block title %}Jobs Structure Settings - Engineering/Drafting Tools{% endblock %}

{% block extra_head %}
<style>
.jstree-container {
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    padding: 1rem;
    background: white;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.jstree-default .jstree-node {
    margin: 0;
    line-height: 1;
}

.jstree-default .jstree-anchor {
    padding: 2px 6px;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    min-height: 24px;
}

.jstree-default .jstree-anchor:hover {
    background-color: #f8fafc;
    border: 1px solid #e2e8f0;
}

.jstree-default .jstree-clicked {
    background-color: #dbeafe !important;
    border: 1px solid #93c5fd !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Let jsTree handle the natural order */
.jstree-default .jstree-ocl {
    width: 16px;
    height: 16px;
    margin-right: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 2px;
    transition: background-color 0.2s ease;
}

.jstree-default .jstree-checkbox {
    margin-right: 6px;
    margin-left: 0;
}


/* Enhanced indentation and visual hierarchy */
.jstree-default .jstree-children {
    padding-left: 0;
}

.jstree-default .jstree-wholerow {
    margin: 0 !important;
    padding: 0 !important;
}

.jstree-default .jstree-wholerow-ul {
    margin: 0 !important;
    padding: 0 !important;
}

.jstree-default .jstree-ocl:hover {
    background-color: #f1f5f9;
}

/* Enhanced indentation - work with jsTree's structure */
.jstree-default .jstree-children {
    padding-left: 24px !important;
}

/* Level-based styling with proper indentation */
.jstree-default .jstree-node[aria-level="1"] .jstree-anchor {
    font-weight: 600;
    color: #1e293b;
    background-color: #f8fafc;
    border-left: 3px solid #3b82f6;
}

.jstree-default .jstree-node[aria-level="2"] .jstree-anchor {
    font-weight: 500;
    color: #334155;
    border-left: 2px solid #64748b;
    margin-left: 8px;
}

.jstree-default .jstree-node[aria-level="3"] .jstree-anchor {
    color: #475569;
    border-left: 1px solid #94a3b8;
    margin-left: 16px;
}

.jstree-default .jstree-node[aria-level="4"] .jstree-anchor {
    color: #64748b;
    font-size: 0.9em;
    margin-left: 24px;
}

.jstree-default .jstree-node[aria-level="5"] .jstree-anchor {
    color: #64748b;
    font-size: 0.9em;
    margin-left: 32px;
}

/* Override jsTree's default spacing */
.jstree-default .jstree-wholerow {
    margin-left: 0 !important;
}

.jstree-default .jstree-anchor {
    margin-left: 0 !important;
    padding-left: 8px !important;
}

/* File vs Folder styling */
.jstree-default .jstree-node[data-type="file"] .jstree-anchor {
    font-style: italic;
}

.jstree-default .jstree-node[data-type="folder"] .jstree-anchor {
    font-weight: 500;
}

/* Icons */
.jstree-default .jstree-icon {
    margin-right: 8px;
    width: 16px;
    height: 16px;
}


/* Hover effects for better UX */
.jstree-default .jstree-node:hover .jstree-anchor {
    transform: translateX(2px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Selected state */
.jstree-default .jstree-selected .jstree-anchor {
    background-color: #dbeafe !important;
    border: 1px solid #93c5fd !important;
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
}
</style>
{% endblock %}

{% block content %}
<div class="hero bg-base-200 rounded-lg mb-8">
    <div class="hero-content text-center">
        <div class="max-w-md">
            <h1 class="text-4xl font-bold">Jobs Structure Settings</h1>
            <p class="py-6">Configure folder structures and file mappings for customer jobs.</p>
        </div>
    </div>
</div>

<!-- Add New Structure Section -->
<div class="card bg-base-100 shadow-xl mb-8">
    <div class="card-body">
        <h2 class="card-title">Add New Customer Structure</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="form-control">
                <label class="label">
                    <span class="label-text">Customer Name</span>
                </label>
                <input type="text" id="customer-name" class="input input-bordered" placeholder="Auto-filled from folder path" readonly>
                <label class="label">
                    <span class="label-text-alt">Customer name will be extracted from the folder path</span>
                </label>
            </div>
            <div class="form-control">
                <label class="label">
                    <span class="label-text">Folder Path</span>
                </label>
                <div class="flex gap-2">
                    <input type="text" id="folder-path" class="input input-bordered flex-1" placeholder="Enter full folder path (e.g., C:\Users\YourName\Documents\CustomerFolder)" oninput="extractCustomerName()">
                    <button class="btn btn-primary" onclick="selectFolder()">Browse</button>
                </div>
                <label class="label">
                    <span class="label-text-alt">Enter the complete path to the customer folder you want to scan</span>
                </label>
            </div>
        </div>
        <div class="card-actions justify-end mt-4">
            <button class="btn btn-primary" onclick="scanFolder()">Scan Folder Structure</button>
        </div>
    </div>
</div>

<!-- Naming Conditions Management -->
<div class="card bg-base-100 shadow-xl mb-4">
    <div class="card-body">
        <h2 class="card-title">
            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8Z"/>
            </svg>
            Naming Conditions
        </h2>
        <p class="text-sm text-base-content/70 mb-4">Define rules to automatically rename items based on patterns.</p>
        
        <!-- Add New Condition Form -->
        <div class="space-y-2 mb-4">
            <div class="flex gap-2">
                <select id="condition-type" class="select select-sm w-32">
                    <option value="contains">Contains</option>
                    <option value="startswith">Starts With</option>
                    <option value="endswith">Ends With</option>
                    <option value="equals">Equals</option>
                    <option value="regex">Regex</option>
                    <option value="intuitive">Intuitive Pattern</option>
                    <option value="extract_job_number">Extract Job Number</option>
                    <option value="extract_customer">Extract Customer</option>
                    <option value="extract_date">Extract Date</option>
                    <option value="not_contains">Not Contains</option>
                    <option value="not_startswith">Not Starts With</option>
                    <option value="not_endswith">Not Ends With</option>
                    <option value="not_equals">Not Equals</option>
                </select>
                <input type="text" 
                       id="condition-pattern" 
                       class="input input-sm flex-1" 
                       placeholder="Pattern (e.g., '1. Sales' or '{d5}' for 5-digit job numbers)">
                <span class="flex items-center text-lg">→</span>
                <input type="text" 
                       id="condition-replacement" 
                       class="input input-sm flex-1" 
                       placeholder="Replacement (e.g., 'Sales' or 'Job {5}')">
                <button class="btn btn-sm btn-primary" onclick="addNamingCondition()">Add Condition</button>
            </div>
            
            <!-- Advanced Chaining Form -->
            <div class="border-t pt-2">
                <div class="text-sm font-medium mb-2">Advanced: Chain Multiple Conditions</div>
                <div class="space-y-2">
                    <div class="flex gap-2 items-center">
                        <select id="chain-operator" class="select select-sm w-20">
                            <option value="AND">AND</option>
                            <option value="OR">OR</option>
                        </select>
                        <select id="chain-condition-type" class="select select-sm w-32">
                            <option value="contains">Contains</option>
                            <option value="startswith">Starts With</option>
                            <option value="endswith">Ends With</option>
                            <option value="equals">Equals</option>
                            <option value="regex">Regex</option>
                            <option value="not_contains">Not Contains</option>
                            <option value="not_startswith">Not Starts With</option>
                            <option value="not_endswith">Not Ends With</option>
                            <option value="not_equals">Not Equals</option>
                        </select>
                        <input type="text" 
                               id="chain-pattern" 
                               class="input input-sm flex-1" 
                               placeholder="Second pattern">
                        <button class="btn btn-sm btn-secondary" onclick="addChainedCondition()">Add Chain</button>
                    </div>
                </div>
            </div>
            
            <div class="text-xs text-base-content/60">
                <strong>Examples:</strong>
                <span class="ml-2">Contains: "1. Sales" → "Sales"</span>
                <span class="ml-2">Job Number: "{d5}" → "Job {5}"</span>
                <span class="ml-2">Customer: "{customer}" → "Customer {customer}"</span>
                <span class="ml-2">Date: "{date}" → "Date {date}"</span>
            </div>
        </div>
        
        <!-- Conditions List -->
        <div id="conditions-list" class="space-y-2 mb-4">
            <!-- Conditions will be loaded here -->
        </div>
        
        <!-- Apply/Undo Conditions Buttons -->
        <div class="flex justify-end gap-2">
            <button class="btn btn-sm btn-error" onclick="undoAllConditions()">
                Undo All Conditions
            </button>
            <button class="btn btn-sm btn-secondary" onclick="applyConditionsToAllStructures()">
                Apply Conditions to All Structures
            </button>
        </div>
    </div>
</div>

<!-- Existing Structures -->
<div id="structures-container">
    <!-- Structures will be loaded here -->
</div>

<!-- Hidden file input for folder selection -->
<input type="file" id="folder-picker" webkitdirectory directory multiple style="display: none;" onchange="handleFolderSelection(event)">
{% endblock %}

{% block extra_scripts %}
<script>
let currentStructures = [];
let namingConditions = [];

// Load existing structures on page load
document.addEventListener('DOMContentLoaded', function() {
    loadStructures();
    loadNamingConditions();
});

// Update alias for an item
function updateAlias(itemIndex, newAlias) {
    // Find the current structure and update the alias
    const currentStructure = currentStructures.find(s => s.id === currentStructureId);
    if (currentStructure && currentStructure.structure_data[itemIndex]) {
        currentStructure.structure_data[itemIndex].alias = newAlias;
        // Save the updated structure
        saveStructure(currentStructure);
    }
}

// Load naming conditions from database
async function loadNamingConditions() {
    try {
        const response = await fetch('/job-structure/api/naming-conditions');
        const data = await response.json();
        if (data.success) {
            namingConditions = data.conditions;
            displayNamingConditions();
        } else {
            console.error('Error loading conditions:', data.error);
        }
    } catch (error) {
        console.error('Error loading conditions:', error);
    }
}

// Save naming condition to database
async function saveNamingCondition(condition) {
    try {
        const response = await fetch('/job-structure/api/naming-conditions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(condition)
        });
        const data = await response.json();
        return data.success;
    } catch (error) {
        console.error('Error saving condition:', error);
        return false;
    }
}

// Update naming condition in database
async function updateNamingConditionInDB(conditionId, updates) {
    try {
        const response = await fetch(`/job-structure/api/naming-conditions/${conditionId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(updates)
        });
        const data = await response.json();
        return data.success;
    } catch (error) {
        console.error('Error updating condition:', error);
        return false;
    }
}

// Delete naming condition from database
async function deleteNamingConditionFromDB(conditionId) {
    try {
        const response = await fetch(`/job-structure/api/naming-conditions/${conditionId}`, {
            method: 'DELETE'
        });
        const data = await response.json();
        return data.success;
    } catch (error) {
        console.error('Error deleting condition:', error);
        return false;
    }
}

// Add a new naming condition
async function addNamingCondition() {
    const conditionType = document.getElementById('condition-type').value;
    const pattern = document.getElementById('condition-pattern').value.trim();
    const replacement = document.getElementById('condition-replacement').value.trim();
    
    if (!pattern || !replacement) {
        showNotification('Please enter both pattern and replacement', 'error');
        return;
    }
    
    const condition = {
        type: conditionType,
        pattern: pattern,
        replacement: replacement,
        enabled: true,
        chains: []
    };
    
    const success = await saveNamingCondition(condition);
    if (success) {
        // Reload conditions from database
        await loadNamingConditions();
        
        // Clear form
        document.getElementById('condition-pattern').value = '';
        document.getElementById('condition-replacement').value = '';
        
        showNotification('Naming condition added successfully', 'success');
    } else {
        showNotification('Failed to add naming condition', 'error');
    }
}

// Add a chained condition to the last added condition
function addChainedCondition() {
    const operator = document.getElementById('chain-operator').value;
    const chainType = document.getElementById('chain-condition-type').value;
    const chainPattern = document.getElementById('chain-pattern').value.trim();
    
    if (!chainPattern) {
        showNotification('Please enter a pattern for the chain', 'error');
        return;
    }
    
    if (namingConditions.length === 0) {
        showNotification('Please add a main condition first', 'error');
        return;
    }
    
    // Add chain to the last condition
    const lastCondition = namingConditions[namingConditions.length - 1];
    lastCondition.chains = lastCondition.chains || [];
    
    lastCondition.chains.push({
        operator: operator,
        type: chainType,
        pattern: chainPattern
    });
    
    saveNamingConditions();
    displayNamingConditions();
    
    // Clear chain form
    document.getElementById('chain-pattern').value = '';
    
    showNotification('Chained condition added successfully', 'success');
}

// Display naming conditions
function displayNamingConditions() {
    const container = document.getElementById('conditions-list');
    if (!container) return;
    
    if (namingConditions.length === 0) {
        container.innerHTML = '<div class="text-sm text-base-content/70">No naming conditions defined</div>';
        return;
    }
    
    container.innerHTML = namingConditions.map(condition => `
        <div class="p-2 bg-base-200 rounded">
            <div class="flex items-center gap-2">
                <input type="checkbox" ${condition.enabled ? 'checked' : ''} 
                       onchange="toggleCondition(${condition.id})">
                <span class="badge badge-sm badge-outline">${condition.type || 'contains'}</span>
                <span class="flex-1 text-sm">
                    <code>${condition.pattern}</code> → <code>${condition.replacement}</code>
                </span>
                <button class="btn btn-xs btn-error" onclick="removeCondition(${condition.id})">Remove</button>
            </div>
            ${condition.chains && condition.chains.length > 0 ? `
                <div class="ml-6 mt-1 text-xs text-base-content/70">
                    ${condition.chains.map(chain => `
                        <span class="badge badge-xs badge-neutral mr-1">${chain.operator}</span>
                        <span class="badge badge-xs badge-outline mr-1">${chain.type}</span>
                        <code>${chain.pattern}</code>
                    `).join(' ')}
                </div>
            ` : ''}
        </div>
    `).join('');
}

// Toggle condition enabled state
async function toggleCondition(conditionId) {
    const condition = namingConditions.find(c => c.id === conditionId);
    if (condition) {
        const newEnabled = !condition.enabled;
        const success = await updateNamingConditionInDB(conditionId, { enabled: newEnabled });
        
        if (success) {
            condition.enabled = newEnabled;
            displayNamingConditions();
            
            // If disabling, apply conditions to remove the effect
            if (!newEnabled) {
                await applyConditionsToAllStructures();
            }
        } else {
            showNotification('Failed to update condition', 'error');
        }
    }
}

// Remove a naming condition
async function removeCondition(conditionId) {
    const success = await deleteNamingConditionFromDB(conditionId);
    
    if (success) {
        // Remove from local array
        namingConditions = namingConditions.filter(c => c.id !== conditionId);
        displayNamingConditions();
        
        // Apply conditions to all structures to remove the effect of deleted condition
        await applyConditionsToAllStructures();
        
        showNotification('Naming condition removed and effects undone', 'info');
    } else {
        showNotification('Failed to remove condition', 'error');
    }
}

// Apply naming conditions to a structure
function applyNamingConditions(structure) {
    if (!structure.structure_data) return structure;
    
    const enabledConditions = namingConditions.filter(c => c.enabled);
    
    structure.structure_data.forEach(item => {
        // Apply each enabled condition
        enabledConditions.forEach(condition => {
            if (matchesCondition(item.name, condition)) {
                item.alias = applyReplacement(item.name, condition);
            }
        });
    });
    
    return structure;
}

// Check if a name matches a condition (including chains)
function matchesCondition(name, condition) {
    // Check main condition
    const mainMatch = checkSingleCondition(name, condition.type, condition.pattern);
    
    // If no chains, return main match
    if (!condition.chains || condition.chains.length === 0) {
        return mainMatch;
    }
    
    // Evaluate chains
    let result = mainMatch;
    
    for (const chain of condition.chains) {
        const chainMatch = checkSingleCondition(name, chain.type, chain.pattern);
        
        if (chain.operator === 'AND') {
            result = result && chainMatch;
        } else if (chain.operator === 'OR') {
            result = result || chainMatch;
        }
    }
    
    return result;
}

// Check a single condition (main or chain)
function checkSingleCondition(name, type, pattern) {
    switch (type) {
        case 'contains':
            return name.includes(pattern);
        case 'startswith':
            return name.startsWith(pattern);
        case 'endswith':
            return name.endsWith(pattern);
        case 'equals':
            return name === pattern;
        case 'regex':
            try {
                const regex = new RegExp(pattern);
                return regex.test(name);
            } catch (e) {
                console.error('Invalid regex pattern:', pattern);
                return false;
            }
        case 'extract_job_number':
            // Look for 5-digit numbers
            return /\d{5}/.test(name);
        case 'extract_customer':
            // Look for common customer name patterns
            return /[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/.test(name);
        case 'extract_date':
            // Look for date patterns (MM/DD/YYYY, YYYY-MM-DD, etc.)
            return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/.test(name);
        case 'intuitive':
            // Convert intuitive patterns to regex and test
            const intuitiveRegex = convertIntuitivePattern(pattern);
            return intuitiveRegex.test(name);
        case 'not_contains':
            return !name.includes(pattern);
        case 'not_startswith':
            return !name.startsWith(pattern);
        case 'not_endswith':
            return !name.endsWith(pattern);
        case 'not_equals':
            return name !== pattern;
        default:
            return name.includes(pattern);
    }
}

// Apply replacement based on condition type
function applyReplacement(name, condition) {
    const pattern = condition.pattern;
    const replacement = condition.replacement;
    const type = condition.type || 'contains';
    
    switch (type) {
        case 'contains':
            return name.replace(pattern, replacement);
        case 'startswith':
            return name.startsWith(pattern) ? name.replace(pattern, replacement) : name;
        case 'endswith':
            return name.endsWith(pattern) ? name.replace(pattern, replacement) : name;
        case 'equals':
            return replacement;
        case 'regex':
            try {
                const regex = new RegExp(pattern);
                return name.replace(regex, replacement);
            } catch (e) {
                console.error('Invalid regex pattern:', pattern);
                return name;
            }
        case 'extract_job_number':
            // Extract 5-digit job number and use in replacement
            const jobMatch = name.match(/\d{5}/);
            if (jobMatch) {
                return replacement.replace('$1', jobMatch[0]);
            }
            return name;
        case 'extract_customer':
            // Extract customer name and use in replacement
            const customerMatch = name.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/);
            if (customerMatch) {
                return replacement.replace('$1', customerMatch[1]);
            }
            return name;
        case 'extract_date':
            // Extract date and use in replacement
            const dateMatch = name.match(/(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2})/);
            if (dateMatch) {
                return replacement.replace('$1', dateMatch[1]);
            }
            return name;
        case 'intuitive':
            // Apply intuitive pattern replacement
            return applyIntuitiveReplacement(name, pattern, replacement);
        case 'not_contains':
        case 'not_startswith':
        case 'not_endswith':
        case 'not_equals':
            return replacement; // For "not" conditions, just use the replacement
        default:
            return name.replace(pattern, replacement);
    }
}

// Convert intuitive patterns to regex
function convertIntuitivePattern(pattern) {
    let regexPattern = pattern;
    
    // Convert intuitive syntax to regex
    regexPattern = regexPattern.replace(/\{d(\d+)\}/g, '(\\d{$1})'); // {d5} -> (\d{5})
    regexPattern = regexPattern.replace(/\{customer\}/g, '([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)'); // {customer} -> customer name pattern
    regexPattern = regexPattern.replace(/\{date\}/g, '(\\d{1,2}[/\\-]\\d{1,2}[/\\-]\\d{2,4}|\\d{4}[/\\-]\\d{1,2}[/\\-]\\d{1,2})'); // {date} -> date pattern
    regexPattern = regexPattern.replace(/\{word\}/g, '(\\w+)'); // {word} -> any word
    regexPattern = regexPattern.replace(/\{text\}/g, '(.+)'); // {text} -> any text
    
    return new RegExp(regexPattern);
}

// Apply intuitive pattern replacement
function applyIntuitiveReplacement(name, pattern, replacement) {
    let regexPattern = pattern;
    const captures = [];
    
    // Convert pattern and collect capture groups
    regexPattern = regexPattern.replace(/\{d(\d+)\}/g, (match, digits) => {
        captures.push({ type: 'digits', count: parseInt(digits) });
        return '(\\d{' + digits + '})';
    });
    
    regexPattern = regexPattern.replace(/\{customer\}/g, () => {
        captures.push({ type: 'customer' });
        return '([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)';
    });
    
    regexPattern = regexPattern.replace(/\{date\}/g, () => {
        captures.push({ type: 'date' });
        return '(\\d{1,2}[/\\-]\\d{1,2}[/\\-]\\d{2,4}|\\d{4}[/\\-]\\d{1,2}[/\\-]\\d{1,2})';
    });
    
    regexPattern = regexPattern.replace(/\{word\}/g, () => {
        captures.push({ type: 'word' });
        return '(\\w+)';
    });
    
    regexPattern = regexPattern.replace(/\{text\}/g, () => {
        captures.push({ type: 'text' });
        return '(.+)';
    });
    
    try {
        const regex = new RegExp(regexPattern);
        const match = name.match(regex);
        
        if (match) {
            let result = replacement;
            
            // Replace {5}, {customer}, etc. with actual values
            for (let i = 0; i < captures.length; i++) {
                const capture = captures[i];
                const value = match[i + 1]; // match[0] is full match
                
                if (capture.type === 'digits') {
                    result = result.replace(new RegExp('\\{' + capture.count + '\\}', 'g'), value);
                } else {
                    result = result.replace(new RegExp('\\{' + capture.type + '\\}', 'g'), value);
                }
            }
            
            return result;
        }
    } catch (e) {
        console.error('Invalid intuitive pattern:', pattern);
    }
    
    return name;
}

// Apply conditions to all structures
async function applyConditionsToAllStructures() {
    try {
        const response = await fetch('/job-structure/api/apply-conditions-to-all', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        const data = await response.json();
        if (data.success) {
            // Reload structures to show updated data
            await loadStructures();
            showNotification(data.message, 'success');
        } else {
            showNotification('Failed to apply conditions: ' + data.error, 'error');
        }
    } catch (error) {
        console.error('Error applying conditions:', error);
        showNotification('Failed to apply conditions', 'error');
    }
}

// Undo all conditions (reset aliases to original names)
async function undoAllConditions() {
    try {
        const response = await fetch('/job-structure/api/undo-conditions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        const data = await response.json();
        if (data.success) {
            // Reload structures to show updated data
            await loadStructures();
            showNotification(data.message, 'success');
        } else {
            showNotification('Failed to undo conditions: ' + data.error, 'error');
        }
    } catch (error) {
        console.error('Error undoing conditions:', error);
        showNotification('Failed to undo conditions', 'error');
    }
}

function selectFolder() {
    document.getElementById('folder-picker').click();
}

function handleFolderSelection(event) {
    const files = event.target.files;
    if (files.length > 0) {
        // Get the actual folder path from the first file
        const firstFile = files[0];
        const fullPath = firstFile.webkitRelativePath;
        const folderName = fullPath.split('/')[0];
        
        // For now, we'll use the folder name and let the user enter the full path
        // In a real implementation, you'd need to use a different approach for getting the full path
        document.getElementById('folder-path').value = folderName;
        
        // Extract customer name from the folder name
        extractCustomerName();
        
        // Show a message to enter the full path
        showNotification('Please enter the full folder path manually in the text field', 'info');
    }
}

function extractCustomerName() {
    const folderPath = document.getElementById('folder-path').value.trim();
    
    if (folderPath) {
        // Strip quotes and get the last part of the path (folder name)
        let cleanPath = folderPath.replace(/^["']|["']$/g, '');
        
        // Split by both forward and backward slashes
        const pathParts = cleanPath.split(/[\\\/]/);
        
        // Get the last non-empty part (the folder name)
        let folderName = pathParts.filter(part => part.length > 0).pop() || '';
        
        // Clean up the folder name (remove common suffixes, clean up formatting)
        folderName = folderName
            .replace(/['"]/g, '') // Remove any remaining quotes
            .replace(/\s+/g, ' ') // Replace multiple spaces with single space
            .trim()
            .toUpperCase(); // Convert to uppercase for consistency
        
        document.getElementById('customer-name').value = folderName;
    } else {
        document.getElementById('customer-name').value = '';
    }
}

async function scanFolder() {
    const customerName = document.getElementById('customer-name').value.trim();
    let folderPath = document.getElementById('folder-path').value.trim();
    
    // Strip quotes from the path
    folderPath = folderPath.replace(/^["']|["']$/g, '');
    
    if (!customerName) {
        showNotification('Please enter a customer name', 'error');
        return;
    }
    
    if (!folderPath) {
        showNotification('Please enter a folder path', 'error');
        return;
    }
    
    // Basic path validation
    if (!folderPath.includes('\\') && !folderPath.includes('/')) {
        showNotification('Please enter a full folder path (e.g., C:\\Users\\YourName\\Documents\\CustomerFolder)', 'error');
        return;
    }
    
    // Show loading state
    const scanButton = document.querySelector('button[onclick="scanFolder()"]');
    const originalText = scanButton.textContent;
    scanButton.textContent = 'Scanning...';
    scanButton.disabled = true;
    
    try {
        const response = await fetch('/job-structure/api/scan-folder', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                customer_name: customerName,
                folder_path: folderPath
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Clear form
            document.getElementById('customer-name').value = '';
            document.getElementById('folder-path').value = '';
            
            // Reload structures
            loadStructures();
            
            // Show success message
            showNotification(`Folder structure scanned successfully! Found ${result.structure.length} items.`, 'success');
        } else {
            showNotification('Error: ' + result.error, 'error');
        }
    } catch (error) {
        showNotification('Error scanning folder: ' + error.message, 'error');
    } finally {
        // Reset button
        scanButton.textContent = originalText;
        scanButton.disabled = false;
    }
}

async function loadStructures() {
    try {
        const response = await fetch('/job-structure/api/get-structures');
        const structures = await response.json();
        currentStructures = structures;
        displayStructures(structures);
    } catch (error) {
        console.error('Error loading structures:', error);
    }
}


function buildTreeData(flatStructure) {
    const pathMap = new Map();
    const rootNodes = [];
    
    // First pass: create all nodes
    flatStructure.forEach((item, index) => {
        const node = {
            id: `item-${index}`,
            text: `<div class="flex items-center gap-2 w-full">
                <span class="flex-1">${item.alias || item.name}</span>
                <input type="text" 
                       class="input input-xs w-32" 
                       placeholder="Variable name" 
                       value="${item.alias || ''}" 
                       onchange="updateAlias(${index}, this.value)"
                       data-item-index="${index}">
            </div>`,
            type: item.type,
            data: {
                originalIndex: index,
                type: item.type,
                included: item.included,
                alias: item.alias || '',
                applications: item.applications || '',
                path: item.path
            },
            state: {
                opened: !item.collapsed
            },
            a_attr: {
                'data-type': item.type
            }
        };
        
        if (item.type === 'folder') {
            node.children = [];
        }
        
        // Store with both original and normalized paths
        pathMap.set(item.path, node);
        pathMap.set(item.path.replace(/\\/g, '/'), node);
    });
    
    // Second pass: build hierarchy
    flatStructure.forEach((item, index) => {
        // Normalize path to use forward slashes for consistency
        const normalizedPath = item.path.replace(/\\/g, '/');
        const pathParts = normalizedPath.split('/');
        const node = pathMap.get(item.path);
        
        if (pathParts.length === 1) {
            // Root level
            rootNodes.push(node);
        } else {
            // Child level - find parent
            const parentPath = pathParts.slice(0, -1).join('/');
            const parent = pathMap.get(parentPath);
            if (parent && parent.children) {
                parent.children.push(node);
            } else {
                // Debug: log missing parent
                console.log(`Missing parent for ${item.name}:`, {
                    itemPath: item.path,
                    normalizedPath: normalizedPath,
                    parentPath: parentPath,
                    pathParts: pathParts
                });
            }
        }
    });
    
    // Debug: log the tree structure
    console.log('Tree data:', rootNodes);
    console.log('Path mapping:', pathMap);
    
    // Debug: check specific paths
    flatStructure.forEach((item, index) => {
        if (item.name === '35394' || item.name === 'Webster City, IA') {
            console.log(`Item ${index}: ${item.name}`, {
                path: item.path,
                type: item.type,
                hasChildren: pathMap.get(item.path)?.children?.length || 0
            });
        }
    });
    
    return rootNodes;
}

function initializeTree(structureId, flatStructure) {
    console.log('Initializing tree for structure:', structureId);
    console.log('Flat structure:', flatStructure);
    
    const treeData = buildTreeData(flatStructure);
    
    // Destroy existing tree if it exists
    if ($(`#tree-${structureId}`).jstree(true)) {
        $(`#tree-${structureId}`).jstree('destroy');
    }
    
    $(`#tree-${structureId}`).jstree({
        'core': {
            'data': treeData,
        'themes': {
            'name': 'default',
            'dots': true,
            'icons': true
        }
        },
        'plugins': ['checkbox', 'wholerow', 'types'],
        'checkbox': {
            'keep_selected_style': false,
            'three_state': false,
            'cascade': 'up+down'
        },
        'types': {
            'folder': {
                'icon': 'fa fa-folder'
            },
            'file': {
                'icon': false
            }
        }
    }).on('ready.jstree', function() {
        console.log('Tree ready for structure:', structureId);
        // Set initial checkbox states
        $(`#tree-${structureId}`).find('li').each(function() {
            const node = $(this).jstree(true).get_node(this.id);
            if (node && node.data) {
                $(this).find('input[type="checkbox"]').prop('checked', node.data.included);
            }
        });
    }).on('changed.jstree', function(e, data) {
        // Handle checkbox changes
        if (data.action === 'select_node' || data.action === 'deselect_node') {
            const node = data.node;
            if (node.data) {
                updateItem(structureId, node.data.originalIndex, 'included', data.selected.includes(node.id));
            }
        }
    });
}


function displayStructures(structures) {
    const container = document.getElementById('structures-container');
    
    if (structures.length === 0) {
        container.innerHTML = '<div class="alert alert-info"><span>No structures found. Add a new customer structure above.</span></div>';
        return;
    }
    
    container.innerHTML = structures.map(structure => `
        <div class="card bg-base-100 shadow-xl mb-4">
            <div class="card-body">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="card-title">${structure.customer_name}</h2>
                    <div class="badge badge-primary">${structure.created_at}</div>
                </div>
                <p class="text-sm text-base-content/70 mb-4">${structure.folder_path}</p>
                
                <div class="flex gap-2 mb-4">
                    <button class="btn btn-sm btn-outline" onclick="expandAllFolders(${structure.id})">Expand All</button>
                    <button class="btn btn-sm btn-outline" onclick="collapseAllFolders(${structure.id})">Collapse All</button>
                    <button class="btn btn-sm btn-error" onclick="clearStructure(${structure.id})">Clear Structure</button>
                </div>
                <div id="tree-${structure.id}" class="jstree-container" style="min-height: 200px;"></div>
            </div>
        </div>
    `).join('');
    
    // Initialize trees after rendering
    structures.forEach(structure => {
        initializeTree(structure.id, structure.structure_data);
    });
}

async function updateItem(structureId, itemIndex, field, value) {
    try {
        const structure = currentStructures.find(s => s.id === structureId);
        if (structure) {
            if (field === 'structure_data') {
                // Update the entire structure data
                structure.structure_data = value;
            } else if (itemIndex < structure.structure_data.length) {
                // Update a specific item field
                structure.structure_data[itemIndex][field] = value;
            }
            
            const response = await fetch('/job-structure/api/update-item', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    structure_id: structureId,
                    structure_data: structure.structure_data
                })
            });
            
            if (response.ok) {
                if (field !== 'collapsed' && field !== 'structure_data') {
                    showNotification('Item added to the USE CONDITIONALLY list', 'success');
                }
            } else {
                showNotification('Error updating item', 'error');
            }
        }
    } catch (error) {
        console.error('Error updating item:', error);
        showNotification('Error updating item: ' + error.message, 'error');
    }
}

function toggleItemAndChildren(structureId, itemIndex, checked) {
    const structure = currentStructures.find(s => s.id === structureId);
    if (!structure) return;
    
    const item = structure.structure_data[itemIndex];
    const hierarchy = buildHierarchy(structure.structure_data);
    const hierarchyItem = hierarchy.find(h => h.originalIndex === itemIndex);
    
    if (!hierarchyItem) return;
    
    // Update the item itself
    item.included = checked;
    
    // If it's a folder, update all children recursively
    if (hierarchyItem.children && hierarchyItem.children.length > 0) {
        updateChildrenIncluded(hierarchyItem, checked, structure.structure_data);
    }
    
    // Update the database
    updateItem(structureId, itemIndex, 'included', checked);
    
    // Re-render the structure
    displayStructures(currentStructures);
}

function updateChildrenIncluded(hierarchyItem, included, flatStructure) {
    hierarchyItem.children.forEach(child => {
        const flatItem = flatStructure[child.originalIndex];
        if (flatItem) {
            flatItem.included = included;
        }
        
        // Recursively update children
        if (child.children && child.children.length > 0) {
            updateChildrenIncluded(child, included, flatStructure);
        }
    });
}

function toggleCollapse(structureId, itemIndex) {
    const structure = currentStructures.find(s => s.id === structureId);
    if (!structure) return;
    
    // Update the collapse state in the flat structure data
    const flatItem = structure.structure_data[itemIndex];
    
    if (flatItem && flatItem.type === 'folder') {
        flatItem.collapsed = !flatItem.collapsed;
        
        // Save to database
        updateItem(structureId, itemIndex, 'collapsed', flatItem.collapsed);
        
        // Re-render the structure
        displayStructures(currentStructures);
    }
}

function expandAllFolders(structureId) {
    $(`#tree-${structureId}`).jstree('open_all');
}

function collapseAllFolders(structureId) {
    $(`#tree-${structureId}`).jstree('close_all');
}

async function clearStructure(structureId) {
    if (!confirm('Are you sure you want to delete this structure? This action cannot be undone.')) {
        return;
    }
    
    try {
        const response = await fetch(`/job-structure/api/delete-structure/${structureId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            // Remove from current structures
            currentStructures = currentStructures.filter(s => s.id !== structureId);
            
            // Re-render the display
            displayStructures(currentStructures);
            
            // Show success message
            showNotification('Structure deleted successfully', 'success');
        } else {
            const error = await response.json();
            showNotification(`Error deleting structure: ${error.error}`, 'error');
        }
    } catch (error) {
        console.error('Error deleting structure:', error);
        showNotification('Error deleting structure', 'error');
    }
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `alert alert-${type} fixed top-4 right-4 z-50 max-w-sm`;
    notification.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span>${message}</span>
        <button class="btn btn-sm btn-ghost" onclick="this.parentElement.remove()">×</button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}
</script>
{% endblock %}
